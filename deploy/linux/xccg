#!/bin/bash

### BEGIN INIT INFO
# Provides:          osxccg(xccg)
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: osxccg(xccg)
# Description:       Cedric Hamelin
### END INIT INFO

# the config of ROOT, user must modify it when start xccg from other directory,
# it's ok to use the script by command ./etc/init.d/xccg

PATH=/bin:/usr/bin:/sbin:/usr/sbin
ROOT="/usr/local/xccg/server"
XCONFTEMPLATE="/usr/local/xccg/xorg_conf_10-nvidia.template"
APP="./run-casparcg.sh"
DEFAULT_PID_FILE='./xccg.pid'

########################################################################
# utility functions
########################################################################
RED="\\033[31m"
GREEN="\\033[32m"
YELLOW="\\033[33m"
BLACK="\\033[0m"
POS="\\033[60G"

ok_msg() {
    echo -e "${1}${POS}${BLACK}[${GREEN}  OK  ${BLACK}]"
}

failed_msg() {
    echo -e "${1}${POS}${BLACK}[${RED}FAILED${BLACK}]"
}

# load process info of xccg
# @set variable $xccg_pid to the process id in xccg.pid file.
# @return 0, if process exists; otherwise:
#       1, for pid file not exists.
#       2, for get proecess info by pid failed.
# @set variable $error_msg if error.
# @set variable $pid_file to pid file.
load_process_info() {
#psefC=`ps -ef|grep "casparcg"|grep -v "casparcg.exe"|grep -v "grep"`
#    if [[ -z "$psefC" ]]; then error_msg="xccg not started"; return 1; fi
#    ok_msg "xccg running"
    testPort=`nc -vz 127.0.0.1 5250 2>&1|grep succeeded`
    if [[ -z "$testPort" ]]; then error_msg="xccg not started"; return 1; fi
    ok_msg "xccg is running"

    return 0;
}

checkXconfig() {
    HAS_GPU=`lspci | grep -i NVIDIA`
    if [[ -z "$HAS_GPU" ]]; then error_msg="server has no GPU"; return 1; fi
    ok_msg "server has GPU"
    BUSID=`nvidia-xconfig --query-gpu-info|grep "PCI BusID"|cut -d':' -f2-|sed 's/ //g'`
    HAS_RIGHT_BUSID=`cat /usr/share/X11/xorg.conf.d/10-nvidia.conf|grep "BusID"|grep "$BUSID"`
    if [[ -z "$HAS_RIGHT_BUSID" ]]
    then
        cat $XCONFTEMPLATE|sed 's/%%BUSID%%/'$BUSID'/g'> /tmp/new_nvidia.conf
        mv /tmp/new_nvidia.conf /usr/share/X11/xorg.conf.d/10-nvidia.conf
        HAS_RIGHT_BUSID=`cat /usr/share/X11/xorg.conf.d/10-nvidia.conf|grep "BusID"|grep "$BUSID"`
        if [[ -z "$HAS_RIGHT_BUSID" ]]
        then
            error_msg="can't configure x server to nvidia gpu ["$BUSID"]"
            return 1
        else
            ok_msg "server is properly configured ["$BUSID"]"
            return 0
        fi
    else
        ok_msg "server is properly configured ["$BUSID"]"
        return 0
    fi
    ok_msg "server is properly configured ["$BUSID"]"
    return 0
}


checkXserver() {
    psefX=`ps -ef|grep "/usr/lib/xorg/Xorg"|grep -v "grep"`
    if [[ -z "$psefX" ]]; then error_msg="X server not started"; return 1; fi
    ok_msg "server X running"
    return 0;
}

startXserver() {
    nohup /usr/bin/X :0 2>/dev/null &
}



start() {
    checkXconfig
    if [[ 1 -eq $? ]]; then failed_msg "server X misconfigured."; return 0; fi

    checkXserver
    if [[ 1 -eq $? ]]; then
        # try start X server
        for ((i = 0; i < 5; i++)); do
            sleep 0.1
            startXserver
            ok_msg "starting X server..."
            sleep 1
            checkXserver
            if [[ 1 -eq $? ]]; then
                sleep 2
                break
            else
                failed_msg "failed to restart X server"
            fi
        done
    fi

    # if exists, exit.
    load_process_info
    if [[ 0 -eq $? ]]; then failed_msg "xccg started, should not start it again."; return 0; fi


    # not exists, start server
    echo ""
    echo "starting xccg..."
    
    # TODO: FIXME: set limit by, for instance, "ulimit -HSn 10000"

    #(ulimit -c unlimited && cd ${ROOT}; export DISPLAY=:0 && nohup ${APP} >/dev/null 2>&1 &)
    (ulimit -c unlimited && cd ${ROOT}; export DISPLAY=:0 && ${APP} >/dev/null 2>&1 &)
    
    # check again after start server
    for ((i = 0; i < 5; i++)); do
        # sleep a little while, for xccg may start then crash.
        sleep 5
        load_process_info
        if [[ 0 -eq $? ]]; then ok_msg "xccg started"; return 0; fi
    done
    load_process_info
    if [[ 1 -eq $? ]]; then failed_msg "xccg start failed"; return 0; fi

    # check whether started.
#    for ((i = 0; i < 5; i++)); do
#        sleep 2
#        load_process_info
#        ret=$?; if [[ 0 -eq $? ]]; then ok_msg "xccg started"; return 0; fi
#    done

    failed_msg "xccg not started"
    return $ret
}

stop() {
    # not start, exit
    # load_process_info
    #    if [[ 0 -ne $? ]]; then failed_msg "xccg not started."; return 0; fi
    
    ok_msg "Stopping xccg..."
    ps -ef|grep "casparcg"|grep -v "grep"|awk 'system("kill -9 "$2)' 2>/dev/null

    # process exists, try to kill to stop normally
    for((i=0;i<100;i++)); do
        load_process_info
        if [[ 0 -eq $? ]]; then
            #kill -s SIGTERM ${xccg_pid} 2>/dev/null
            ps -ef|grep "casparcg"|grep -v "grep"|awk 'system("kill -9 "$2)' 2>/dev/null
            ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "send signal SIGTERM failed ret=$ret"; return $ret; fi
            sleep 0.3
        else
            ok_msg "xccg stopped by SIGTERM"
            # delete the pid file when stop success.
            #rm -f ${pid_file}
            break;
        fi
    done
    
    # process exists, use kill -9 to force to exit
    load_process_info
    if [[ 0 -eq $? ]]; then
        kill -s SIGKILL ${xccg_pid} 2>/dev/null
        ret=$?; if [[ 0 -ne $ret ]]; then failed_msg "send signal SIGKILL failed ret=$ret"; return $ret; fi
        ok_msg "xccg stopped by SIGKILL"
    else
        # delete the pid file when stop success.
        rm -f ${pid_file}
    fi
    
    sleep 0.1
    return 0
}

# get the status of xccg process
# @return 0 if xccg is running; otherwise, 1 for stopped.
status() {
    load_process_info
    ret=$?; if [[ 0 -eq $ret ]]; then return 0; fi
    
    failed_msg "xccg is stopped, $error_msg"
    return 1
}


menu() {
    case "$1" in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            stop
            start
            ;;
        status)
            status
            ;;
        *)
            echo "Usage: $0 {start|stop|status}"
            return 1
            ;;
    esac
}

menu $1

code=$?
exit ${code}


